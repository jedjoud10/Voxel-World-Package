// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel VoxelMain
#pragma kernel VoxelNormal
#include "./GenerationShaders/Others/SDFFunctions.cginc"
#include "./GenerationShaders/Others/noises/base.cginc"
#include "./GenerationShaders/Others/noises/cellular3D.cginc"
#include "./GenerationShaders/Others/noises/noise3D.cginc"
#include "./GenerationShaders/Others/noises/erosionnoise.cginc"
#define PLANET_SIZE 10000

//Base values
float3 offset;
float3 scale;
float chunkScaling;
int resolution;
float quality;

//Data stuff
struct Voxel
{
    float density;
    float3 color;
    float3 normal;
    float smoothness;
    float metallic;
};
RWStructuredBuffer<Voxel> buffer;
RWTexture2D<float3> animeTexture;
//Snow biome
float SnowBiome(float3 p)
{
    float noiseDensity = 0;
    float maxNoiseDensity = 0;
    for (int i = 0; i < 3; i++)
    {
        noiseDensity += (snoise((p * 0.0005 + 5) * pow(2.05, i))) * pow(0.5, i);
        maxNoiseDensity += pow(0.5, i);
    }
    return (abs(p.y) - PLANET_SIZE / 1.3) / 100 + (noiseDensity / maxNoiseDensity) * 10;
}
//Ocean biome
float OceanBiome(float3 p) 
{
    float noiseDensity = 0;
    float maxNoiseDensity = 0;
    for (int i = 0; i < 5; i++)
    {
        noiseDensity += (cellular((p * 0.0001 + 5) * pow(2.05, i))) * pow(0.5, i);
        maxNoiseDensity += pow(0.5, i);
    }
    return -(noiseDensity / maxNoiseDensity) + 0.6;
}
//Example generator
float Density(float3 p, float3 lp)
{
    float density = 0;
    float2 noiseDensity = 0;
    float2 maxNoiseDensity = 0;
    for (int i = 0; i < 8 * quality; i++)
    {
        noiseDensity += (1 - cellular((p * 0.001 + 5) * pow(1.9, i))) * pow(0.48, i);
        maxNoiseDensity += pow(0.5, i);
    }
    noiseDensity /= maxNoiseDensity;
    float sphere = sdSphere(p, PLANET_SIZE);
    density = opSmoothUnion(sphere + noiseDensity.x * 900 - 400, sphere, 190);
    density = lerp(density, sphere, saturate(OceanBiome(p) * 30));
    density = lerp(density, sphere + noiseDensity.y * 100, saturate(SnowBiome(p)));
    /*
    if (density < -100)
    {
        noiseDensity = 0;
        maxNoiseDensity = 0;
        for (int i = 0; i < 2 * quality; i++)
        {
            noiseDensity += (1 - cellular((p * 0.01 + 5) * pow(2, i) * float3(1, 1, 1))) * pow(0.5, i);
            maxNoiseDensity += pow(0.5, i);
        }
        density = ((noiseDensity - 0.9) * 900) * saturate((snoise(p * 0.002 * float3(1, 3, 1)) - 0.2) * 10);
    }
    */
    return density;
}
//The color function
float3 Color(float3 p, float3 lp, float3 n)
{
    float3 color = n;
    color = lerp(0.5, float3(27, 181, 35) / 255.0, saturate(dot(n, normalize(p)) * 20 - 17));
    color = lerp(color, lerp(float3(16, 190, 224) / 255, float3(18, 29, 117) / 255, saturate(OceanBiome(p) * 2)), saturate(OceanBiome(p) * 20));
    color = lerp(color, lerp(0.5, 1, saturate(dot(n, normalize(p)) * 20 - 17)), saturate(SnowBiome(p)));
    return color;
}
//The metallic function
float Metallic(float3 p, float3 lp, float3 n)
{
    float metallic = 0;
    metallic = 0;
    metallic = lerp(metallic, saturate(OceanBiome(p) * 2), saturate(OceanBiome(p) * 20));
    metallic = lerp(metallic, 0.2, saturate(SnowBiome(p)));
    return metallic;
}
//The Smoothness function
float Smoothness(float3 p, float3 lp, float3 n)
{
    float smoothness = 0;
    smoothness = 0;
    smoothness = lerp(smoothness, saturate(OceanBiome(p) > 0), saturate(OceanBiome(p) * 20));
    smoothness = lerp(smoothness, 0.2, saturate(SnowBiome(p)));
    return smoothness;
}
int flt(uint3 pos) { return (pos.z * resolution * resolution) + (pos.y * resolution) + pos.x; }

[numthreads(8, 8, 8)]
void VoxelMain(uint3 id : SV_DispatchThreadID)
{
    float3 p = (id * chunkScaling + offset) * scale;

    Voxel voxel;
    voxel.density = Density(p, id / (float)resolution);
    voxel.normal = 1;
    voxel.color = 1;
    voxel.metallic = 0;
    voxel.smoothness = 0;
    buffer[(id.z * resolution * resolution) + (id.y * resolution) + id.x] = voxel;
}

[numthreads(8, 8, 8)]
void VoxelNormal(uint3 id : SV_DispatchThreadID)
{
    float3 p = (id * chunkScaling + offset) * scale;
    int index = flt(id);
    Voxel voxel = buffer[index];
    float3 normal = 0;
    normal.x = buffer[flt(uint3(1, 0, 0) + id)].density - buffer[flt(uint3(-1, 0, 0) + id)].density;
    normal.y = buffer[flt(uint3(0, 1, 0) + id)].density - buffer[flt(uint3(0, -1, 0) + id)].density;
    normal.z = buffer[flt(uint3(0, 0, 1) + id)].density - buffer[flt(uint3(0, 0, -1) + id)].density;
    normal = normalize(normal);

    voxel.normal = normal;
    voxel.color = Color(p, id / (float)resolution, normal);
    voxel.metallic = Metallic(p, id / (float)resolution, normal);
    voxel.smoothness = Smoothness(p, id / (float)resolution, normal);
    buffer[index] = voxel;
}