// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel VoxelMain
#pragma kernel VoxelNormal
#include "./GenerationShaders/Others/SDFFunctions.cginc"
#include "./GenerationShaders/Others/noises/base.cginc"
#include "./GenerationShaders/Others/noises/cellular3D.cginc"
#include "./GenerationShaders/Others/noises/noise3D.cginc"
#include "./GenerationShaders/Others/noises/erosionnoise.cginc"

//Base values
float3 offset;
float3 scale;
float chunkScaling;
int resolution;
float quality;

//Data stuff
struct Voxel
{
    float density;
    float3 color;
    float3 normal;
    float2 sm;
};
struct ColorSmoothnessMetallic 
{
    float3 color;
    float2 sm;
};
RWStructuredBuffer<Voxel> buffer;


//FbM functions
float fbmSnoise(float3 p, float pe, float la, int o)
{
    float noiseDensity = 0;
    float maxNoiseDensity = 0;
    for (int i = 0; i < o * quality; i++)
    {
        noiseDensity += (snoise((p) * pow(la, i)) * pow(pe, i));
        maxNoiseDensity += pow(pe, i);
    }
    return noiseDensity / maxNoiseDensity;
}


//---Biomes---
//Mountains
float MountainsBiomeDensity(float3 p)
{
    float density = 0;
    float noiseDensity = mountain(p.xz * 0.01, 0.2);
    density = opSmoothUnion((1 - noiseDensity) * 800 + p.y - 450, p.y, 120);
    return density;
}
ColorSmoothnessMetallic MountainsBiomeCSM(float3 p, float3 lp, float3 n)
{
    ColorSmoothnessMetallic csm;
    csm.color = lerp(0.5, 1, saturate((dot(n, float3(0, 1, 0)) - 0.75) * 10));
    csm.sm = 0;
    return csm;
}


//Frozen Lake
float FrozenLakeBiomeDensity(float3 p) 
{
    return p.y;
}
ColorSmoothnessMetallic FrozenLakeBiomeCSM(float3 p, float3 lp, float3 n, float noise)
{
    ColorSmoothnessMetallic csm;
    csm.color = lerp(float3(49, 72, 94) / 255, 1, noise);
    csm.sm = lerp(0.8, 0, noise + snoise(p * 3) * 0.02);
    return csm;
}


//Density function
float Density(float3 p, float3 lp)
{
    return FrozenLakeBiomeDensity(p);
}
//Get the color, smoothness, and metallic all in one function
ColorSmoothnessMetallic GetCSM(float3 p, float3 lp, float3 n)
{
    ColorSmoothnessMetallic csm;
    float frozenLakeNoise = saturate(((fbmSnoise(p * 0.01, 0.6, 2.4, 4) + 1) / 2));
    frozenLakeNoise = saturate(((frozenLakeNoise - 0.5) * 6));
    //return MountainsBiomeCSM(p, lp, n);
    return FrozenLakeBiomeCSM(p, lp, n, frozenLakeNoise);
}

int flt(uint3 pos) { return (pos.z * resolution * resolution) + (pos.y * resolution) + pos.x; }
[numthreads(8, 8, 8)]
void VoxelMain(uint3 id : SV_DispatchThreadID)
{
    float3 p = (id * chunkScaling + offset) * scale;

    Voxel voxel;
    voxel.density = Density(p, id / (float)resolution);
    voxel.normal = 1;
    voxel.color = 1;
    voxel.sm = 0;
    buffer[(id.z * resolution * resolution) + (id.y * resolution) + id.x] = voxel;
}

[numthreads(8, 8, 8)]
void VoxelNormal(uint3 id : SV_DispatchThreadID)
{
    float3 p = (id * chunkScaling + offset) * scale;
    int index = flt(id);
    Voxel voxel = buffer[index];
    float3 normal = 0;
    normal.x = buffer[flt(uint3(1, 0, 0) + id)].density - buffer[flt(uint3(-1, 0, 0) + id)].density;
    normal.y = buffer[flt(uint3(0, 1, 0) + id)].density - buffer[flt(uint3(0, -1, 0) + id)].density;
    normal.z = buffer[flt(uint3(0, 0, 1) + id)].density - buffer[flt(uint3(0, 0, -1) + id)].density;
    normal = normalize(normal);

    voxel.normal = normal;
    ColorSmoothnessMetallic csm = GetCSM(p, id / (float)resolution, normal);
    voxel.color = csm.color;
    voxel.sm = saturate(csm.sm);
    buffer[index] = voxel;
}