// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel VoxelMain
#pragma kernel VoxelNormal
#include "./GenerationShaders/Others/SDFFunctions.cginc"
#include "./GenerationShaders/Others/noises/base.cginc"
#include "./GenerationShaders/Others/noises/cellular3D.cginc"
#include "./GenerationShaders/Others/noises/noise3D.cginc"
#include "./GenerationShaders/Others/noises/erosionnoise.cginc"

//Base values
int resolution;
float3 scale;
int chunksRanInParallel;

//CPU-GPU Structs
struct Voxel 
{
    float density;
    float3 color;
    float3 normal;
    float smoothness;
    float metallic;
};
struct GPUChunkData
{
    float3 offset;
    float chunkScaling;
    float quality;
};

RWStructuredBuffer<Voxel> voxelsBuffer;
RWStructuredBuffer<GPUChunkData> chunksBuffer;
RWTexture2D<float3> animeTexture;
//P: 3D Point
//N: Normal
//The density function
float Density(float3 p, GPUChunkData chunk) 
{
    float cellularDensity = 0;
    float maxv = 0;
    for (int i = 0; i < 8 * chunk.quality; i++)
    {
        cellularDensity += (1 - cellular(p * pow(2, i) * 0.002)) * pow(0.5, i);
        maxv += pow(0.5, i);
    }
    cellularDensity /= maxv;
    cellularDensity *= 620;
    //return p.y;
    return opUnion(opSubtraction(sdBox(p, float3(100, 100, 100)), sdSphere(p, 110)), opUnion(cellularDensity + p.y - 320, p.y));
    float sphere = sdSphere(p, 5000);
    return opSmoothUnion(cellularDensity + sphere, sdSphere(p, 4850), 60);
    return cellularDensity + sphere;
}
//The color function
float3 Color(float3 p, float3 lp, float3 n, GPUChunkData chunk)
{
    float3 color = animeTexture[(p.xz + 1024)*0.58];
    color = saturate(p.y / 320);
    return color;
}
//The metallic function
float Metallic(float3 p, float3 n, GPUChunkData chunk)
{
    return 0;
}
//The Smoothness function
float Smoothness(float3 p, float3 n, GPUChunkData chunk)
{
    return 0;
}
inline int flt(uint3 pos) { return (pos.z * resolution * resolution) + (pos.y * resolution) + pos.x; }

[numthreads(8,8,8)]
void VoxelMain(uint3 id1 : SV_DispatchThreadID)
{    
    //Get the corresponding chunk and correct id
    GPUChunkData chunk = chunksBuffer[id1.x / resolution];
    uint3 id = int3(id1.x % resolution, id1.yz);

    //Index offset used to turn the local index into a global voxel position
    uint idxOffset = (id1.x / resolution) * (resolution * resolution * resolution);
    int index = flt(id) + idxOffset;

    //Calculate the local-chunk voxel position
    float3 p = (id * chunk.chunkScaling + chunk.offset) * scale;    
    Voxel voxel;

    //Apply the density
    voxel.density = Density(p, chunk);
    voxel.normal = 1;
    voxel.color = 1;
    voxel.metallic = 0;
    voxel.smoothness = 0;
    voxelsBuffer[index] = voxel;
}

[numthreads(8, 8, 8)]
void VoxelNormal(uint3 id1 : SV_DispatchThreadID)
{
    //Get the corresponding chunk and correct id
    GPUChunkData chunk = chunksBuffer[id1.x / resolution];
    uint3 id = uint3(id1.x % resolution, id1.yz);

    //Index offset used to turn the local index into a global voxel position
    uint idxOffset = (id1.x / resolution) * (resolution * resolution * resolution);
    int index = flt(id) + idxOffset;

    //Calculate the local-chunk voxel position
    float3 p = (id * chunk.chunkScaling + chunk.offset) * scale;
    Voxel voxel = voxelsBuffer[index];
    
    //Calculate the normal
    float3 normal = 0;
    normal.x = voxelsBuffer[flt(uint3(1, 0, 0) + id) + idxOffset].density - voxelsBuffer[flt(uint3(-1, 0, 0) + id) + idxOffset].density;
    normal.y = voxelsBuffer[flt(uint3(0, 1, 0) + id) + idxOffset].density - voxelsBuffer[flt(uint3(0, -1, 0) + id) + idxOffset].density;
    normal.z = voxelsBuffer[flt(uint3(0, 0, 1) + id) + idxOffset].density - voxelsBuffer[flt(uint3(0, 0, -1) + id) + idxOffset].density;
    normal = normalize(normal);

    //Apply everything
    voxel.normal = normal;
    voxel.color = Color(p, id / (float)resolution, normal, chunk);
    voxel.color = (id1.x / resolution) / (float)chunksRanInParallel;
    voxel.metallic = Metallic(p, normal, chunk);
    voxel.smoothness = Smoothness(p, normal, chunk);
    voxelsBuffer[index] = voxel;
}
