// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel VoxelMain
#pragma kernel VoxelNormal
#include "./GenerationShaders/ExampleGenerator.cginc"

//Base values
float3 offset;
float3 scale;
float chunkScaling;
int resolution;
float quality;

//Data stuff
struct Voxel 
{
    float density;
    float3 color;
    float3 normal;
    float smoothness;
    float metallic;
};
RWStructuredBuffer<Voxel> buffer;
RWTexture2D<float3> animeTexture;
int flt(uint3 pos) { return (pos.z * resolution * resolution) + (pos.y * resolution) + pos.x; }

[numthreads(8,8,8)]
void VoxelMain(uint3 id : SV_DispatchThreadID)
{
    float3 p = (id * chunkScaling + offset) * scale;
    
    Voxel voxel;
    voxel.density = Density(p, id / (float)resolution);
    voxel.normal = 1;
    voxel.color = 1;
    voxel.metallic = 0;
    voxel.smoothness = 0;
    buffer[(id.z * resolution * resolution) + (id.y * resolution) + id.x] = voxel;
}

[numthreads(8, 8, 8)]
void VoxelNormal(uint3 id : SV_DispatchThreadID)
{
    float3 p = (id * chunkScaling + offset) * scale;
    int index = flt(id);
    Voxel voxel = buffer[index];
    float3 normal = 0;
    normal.x = buffer[flt(uint3(1, 0, 0) + id)].density - buffer[flt(uint3(-1, 0, 0) + id)].density;
    normal.y = buffer[flt(uint3(0, 1, 0) + id)].density - buffer[flt(uint3(0, -1, 0) + id)].density;
    normal.z = buffer[flt(uint3(0, 0, 1) + id)].density - buffer[flt(uint3(0, 0, -1) + id)].density;
    normal = normalize(normal);

    voxel.normal = normal;
    voxel.color = Color(p, id / (float)resolution, normal);
    voxel.metallic = Metallic(p, id / (float)resolution, normal);
    voxel.smoothness = Smoothness(p, id / (float)resolution, normal);
    buffer[index] = voxel;
}
